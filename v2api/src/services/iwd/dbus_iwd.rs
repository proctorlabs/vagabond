// This code was autogenerated with `dbus-codegen-rust -s --file dbus/introspection.xml -c nonblock -p / -m none -i net.connman.iwd`, see https://github.com/diwic/dbus-rs
use dbus;
#[allow(unused_imports)]
use dbus::arg;
use dbus::nonblock;

pub trait OrgFreedesktopDBusObjectManager {
    fn get_managed_objects(
        &self,
    ) -> nonblock::MethodReply<
        ::std::collections::HashMap<
            dbus::Path<'static>,
            ::std::collections::HashMap<String, arg::PropMap>,
        >,
    >;
}

impl<'a, T: nonblock::NonblockReply, C: ::std::ops::Deref<Target = T>>
    OrgFreedesktopDBusObjectManager for nonblock::Proxy<'a, C>
{
    fn get_managed_objects(
        &self,
    ) -> nonblock::MethodReply<
        ::std::collections::HashMap<
            dbus::Path<'static>,
            ::std::collections::HashMap<String, arg::PropMap>,
        >,
    > {
        self.method_call(
            "org.freedesktop.DBus.ObjectManager",
            "GetManagedObjects",
            (),
        )
        .and_then(
            |r: (
                ::std::collections::HashMap<
                    dbus::Path<'static>,
                    ::std::collections::HashMap<String, arg::PropMap>,
                >,
            )| Ok(r.0),
        )
    }
}

#[derive(Debug)]
pub struct OrgFreedesktopDBusObjectManagerInterfacesAdded {
    pub object_path: dbus::Path<'static>,
    pub interfaces_and_properties: ::std::collections::HashMap<String, arg::PropMap>,
}

impl arg::AppendAll for OrgFreedesktopDBusObjectManagerInterfacesAdded {
    fn append(&self, i: &mut arg::IterAppend) {
        arg::RefArg::append(&self.object_path, i);
        arg::RefArg::append(&self.interfaces_and_properties, i);
    }
}

impl arg::ReadAll for OrgFreedesktopDBusObjectManagerInterfacesAdded {
    fn read(i: &mut arg::Iter) -> Result<Self, arg::TypeMismatchError> {
        Ok(OrgFreedesktopDBusObjectManagerInterfacesAdded {
            object_path: i.read()?,
            interfaces_and_properties: i.read()?,
        })
    }
}

impl dbus::message::SignalArgs for OrgFreedesktopDBusObjectManagerInterfacesAdded {
    const NAME: &'static str = "InterfacesAdded";
    const INTERFACE: &'static str = "org.freedesktop.DBus.ObjectManager";
}

#[derive(Debug)]
pub struct OrgFreedesktopDBusObjectManagerInterfacesRemoved {
    pub object_path: dbus::Path<'static>,
    pub interfaces: Vec<String>,
}

impl arg::AppendAll for OrgFreedesktopDBusObjectManagerInterfacesRemoved {
    fn append(&self, i: &mut arg::IterAppend) {
        arg::RefArg::append(&self.object_path, i);
        arg::RefArg::append(&self.interfaces, i);
    }
}

impl arg::ReadAll for OrgFreedesktopDBusObjectManagerInterfacesRemoved {
    fn read(i: &mut arg::Iter) -> Result<Self, arg::TypeMismatchError> {
        Ok(OrgFreedesktopDBusObjectManagerInterfacesRemoved {
            object_path: i.read()?,
            interfaces: i.read()?,
        })
    }
}

impl dbus::message::SignalArgs for OrgFreedesktopDBusObjectManagerInterfacesRemoved {
    const NAME: &'static str = "InterfacesRemoved";
    const INTERFACE: &'static str = "org.freedesktop.DBus.ObjectManager";
}

pub trait AgentManager {
    fn register_agent(&self, path: dbus::Path) -> nonblock::MethodReply<()>;
    fn unregister_agent(&self, path: dbus::Path) -> nonblock::MethodReply<()>;
}

impl<'a, T: nonblock::NonblockReply, C: ::std::ops::Deref<Target = T>> AgentManager
    for nonblock::Proxy<'a, C>
{
    fn register_agent(&self, path: dbus::Path) -> nonblock::MethodReply<()> {
        self.method_call("net.connman.iwd.AgentManager", "RegisterAgent", (path,))
    }

    fn unregister_agent(&self, path: dbus::Path) -> nonblock::MethodReply<()> {
        self.method_call("net.connman.iwd.AgentManager", "UnregisterAgent", (path,))
    }
}

pub trait P2pServiceManager {
    fn register_display_service(&self, properties: arg::PropMap) -> nonblock::MethodReply<()>;
    fn unregister_display_service(&self) -> nonblock::MethodReply<()>;
}

impl<'a, T: nonblock::NonblockReply, C: ::std::ops::Deref<Target = T>> P2pServiceManager
    for nonblock::Proxy<'a, C>
{
    fn register_display_service(&self, properties: arg::PropMap) -> nonblock::MethodReply<()> {
        self.method_call(
            "net.connman.iwd.p2p.ServiceManager",
            "RegisterDisplayService",
            (properties,),
        )
    }

    fn unregister_display_service(&self) -> nonblock::MethodReply<()> {
        self.method_call(
            "net.connman.iwd.p2p.ServiceManager",
            "UnregisterDisplayService",
            (),
        )
    }
}

pub trait Adapter {
    fn powered(&self) -> nonblock::MethodReply<bool>;
    fn set_powered(&self, value: bool) -> nonblock::MethodReply<()>;
    fn model(&self) -> nonblock::MethodReply<String>;
    fn vendor(&self) -> nonblock::MethodReply<String>;
    fn name(&self) -> nonblock::MethodReply<String>;
    fn supported_modes(&self) -> nonblock::MethodReply<Vec<String>>;
}

impl<'a, T: nonblock::NonblockReply, C: ::std::ops::Deref<Target = T>> Adapter
    for nonblock::Proxy<'a, C>
{
    fn powered(&self) -> nonblock::MethodReply<bool> {
        <Self as nonblock::stdintf::org_freedesktop_dbus::Properties>::get(
            &self,
            "net.connman.iwd.Adapter",
            "Powered",
        )
    }

    fn model(&self) -> nonblock::MethodReply<String> {
        <Self as nonblock::stdintf::org_freedesktop_dbus::Properties>::get(
            &self,
            "net.connman.iwd.Adapter",
            "Model",
        )
    }

    fn vendor(&self) -> nonblock::MethodReply<String> {
        <Self as nonblock::stdintf::org_freedesktop_dbus::Properties>::get(
            &self,
            "net.connman.iwd.Adapter",
            "Vendor",
        )
    }

    fn name(&self) -> nonblock::MethodReply<String> {
        <Self as nonblock::stdintf::org_freedesktop_dbus::Properties>::get(
            &self,
            "net.connman.iwd.Adapter",
            "Name",
        )
    }

    fn supported_modes(&self) -> nonblock::MethodReply<Vec<String>> {
        <Self as nonblock::stdintf::org_freedesktop_dbus::Properties>::get(
            &self,
            "net.connman.iwd.Adapter",
            "SupportedModes",
        )
    }

    fn set_powered(&self, value: bool) -> nonblock::MethodReply<()> {
        <Self as nonblock::stdintf::org_freedesktop_dbus::Properties>::set(
            &self,
            "net.connman.iwd.Adapter",
            "Powered",
            value,
        )
    }
}

pub trait OrgFreedesktopDBusProperties {
    fn get(
        &self,
        interface_name: &str,
        property_name: &str,
    ) -> nonblock::MethodReply<arg::Variant<Box<dyn arg::RefArg + 'static>>>;
    fn set(
        &self,
        interface_name: &str,
        property_name: &str,
        value: arg::Variant<Box<dyn arg::RefArg>>,
    ) -> nonblock::MethodReply<()>;
    fn get_all(&self, interface_name: &str) -> nonblock::MethodReply<arg::PropMap>;
}

impl<'a, T: nonblock::NonblockReply, C: ::std::ops::Deref<Target = T>> OrgFreedesktopDBusProperties
    for nonblock::Proxy<'a, C>
{
    fn get(
        &self,
        interface_name: &str,
        property_name: &str,
    ) -> nonblock::MethodReply<arg::Variant<Box<dyn arg::RefArg + 'static>>> {
        self.method_call(
            "org.freedesktop.DBus.Properties",
            "Get",
            (interface_name, property_name),
        )
        .and_then(|r: (arg::Variant<Box<dyn arg::RefArg + 'static>>,)| Ok(r.0))
    }

    fn set(
        &self,
        interface_name: &str,
        property_name: &str,
        value: arg::Variant<Box<dyn arg::RefArg>>,
    ) -> nonblock::MethodReply<()> {
        self.method_call(
            "org.freedesktop.DBus.Properties",
            "Set",
            (interface_name, property_name, value),
        )
    }

    fn get_all(&self, interface_name: &str) -> nonblock::MethodReply<arg::PropMap> {
        self.method_call(
            "org.freedesktop.DBus.Properties",
            "GetAll",
            (interface_name,),
        )
        .and_then(|r: (arg::PropMap,)| Ok(r.0))
    }
}

#[derive(Debug)]
pub struct OrgFreedesktopDBusPropertiesPropertiesChanged {
    pub interface_name: String,
    pub changed_properties: arg::PropMap,
    pub invalidated_properties: Vec<String>,
}

impl arg::AppendAll for OrgFreedesktopDBusPropertiesPropertiesChanged {
    fn append(&self, i: &mut arg::IterAppend) {
        arg::RefArg::append(&self.interface_name, i);
        arg::RefArg::append(&self.changed_properties, i);
        arg::RefArg::append(&self.invalidated_properties, i);
    }
}

impl arg::ReadAll for OrgFreedesktopDBusPropertiesPropertiesChanged {
    fn read(i: &mut arg::Iter) -> Result<Self, arg::TypeMismatchError> {
        Ok(OrgFreedesktopDBusPropertiesPropertiesChanged {
            interface_name: i.read()?,
            changed_properties: i.read()?,
            invalidated_properties: i.read()?,
        })
    }
}

impl dbus::message::SignalArgs for OrgFreedesktopDBusPropertiesPropertiesChanged {
    const NAME: &'static str = "PropertiesChanged";
    const INTERFACE: &'static str = "org.freedesktop.DBus.Properties";
}

pub trait P2pDevice {
    fn get_peers(&self) -> nonblock::MethodReply<Vec<(dbus::Path<'static>, i16)>>;
    fn request_discovery(&self) -> nonblock::MethodReply<()>;
    fn release_discovery(&self) -> nonblock::MethodReply<()>;
    fn enabled(&self) -> nonblock::MethodReply<bool>;
    fn set_enabled(&self, value: bool) -> nonblock::MethodReply<()>;
    fn name(&self) -> nonblock::MethodReply<String>;
    fn set_name(&self, value: String) -> nonblock::MethodReply<()>;
    fn available_connections(&self) -> nonblock::MethodReply<u16>;
}

impl<'a, T: nonblock::NonblockReply, C: ::std::ops::Deref<Target = T>> P2pDevice
    for nonblock::Proxy<'a, C>
{
    fn get_peers(&self) -> nonblock::MethodReply<Vec<(dbus::Path<'static>, i16)>> {
        self.method_call("net.connman.iwd.p2p.Device", "GetPeers", ())
            .and_then(|r: (Vec<(dbus::Path<'static>, i16)>,)| Ok(r.0))
    }

    fn request_discovery(&self) -> nonblock::MethodReply<()> {
        self.method_call("net.connman.iwd.p2p.Device", "RequestDiscovery", ())
    }

    fn release_discovery(&self) -> nonblock::MethodReply<()> {
        self.method_call("net.connman.iwd.p2p.Device", "ReleaseDiscovery", ())
    }

    fn enabled(&self) -> nonblock::MethodReply<bool> {
        <Self as nonblock::stdintf::org_freedesktop_dbus::Properties>::get(
            &self,
            "net.connman.iwd.p2p.Device",
            "Enabled",
        )
    }

    fn name(&self) -> nonblock::MethodReply<String> {
        <Self as nonblock::stdintf::org_freedesktop_dbus::Properties>::get(
            &self,
            "net.connman.iwd.p2p.Device",
            "Name",
        )
    }

    fn available_connections(&self) -> nonblock::MethodReply<u16> {
        <Self as nonblock::stdintf::org_freedesktop_dbus::Properties>::get(
            &self,
            "net.connman.iwd.p2p.Device",
            "AvailableConnections",
        )
    }

    fn set_enabled(&self, value: bool) -> nonblock::MethodReply<()> {
        <Self as nonblock::stdintf::org_freedesktop_dbus::Properties>::set(
            &self,
            "net.connman.iwd.p2p.Device",
            "Enabled",
            value,
        )
    }

    fn set_name(&self, value: String) -> nonblock::MethodReply<()> {
        <Self as nonblock::stdintf::org_freedesktop_dbus::Properties>::set(
            &self,
            "net.connman.iwd.p2p.Device",
            "Name",
            value,
        )
    }
}

pub trait Device {
    fn name(&self) -> nonblock::MethodReply<String>;
    fn address(&self) -> nonblock::MethodReply<String>;
    fn powered(&self) -> nonblock::MethodReply<bool>;
    fn set_powered(&self, value: bool) -> nonblock::MethodReply<()>;
    fn adapter(&self) -> nonblock::MethodReply<dbus::Path<'static>>;
    fn mode(&self) -> nonblock::MethodReply<String>;
    fn set_mode(&self, value: String) -> nonblock::MethodReply<()>;
}

impl<'a, T: nonblock::NonblockReply, C: ::std::ops::Deref<Target = T>> Device
    for nonblock::Proxy<'a, C>
{
    fn name(&self) -> nonblock::MethodReply<String> {
        <Self as nonblock::stdintf::org_freedesktop_dbus::Properties>::get(
            &self,
            "net.connman.iwd.Device",
            "Name",
        )
    }

    fn address(&self) -> nonblock::MethodReply<String> {
        <Self as nonblock::stdintf::org_freedesktop_dbus::Properties>::get(
            &self,
            "net.connman.iwd.Device",
            "Address",
        )
    }

    fn powered(&self) -> nonblock::MethodReply<bool> {
        <Self as nonblock::stdintf::org_freedesktop_dbus::Properties>::get(
            &self,
            "net.connman.iwd.Device",
            "Powered",
        )
    }

    fn adapter(&self) -> nonblock::MethodReply<dbus::Path<'static>> {
        <Self as nonblock::stdintf::org_freedesktop_dbus::Properties>::get(
            &self,
            "net.connman.iwd.Device",
            "Adapter",
        )
    }

    fn mode(&self) -> nonblock::MethodReply<String> {
        <Self as nonblock::stdintf::org_freedesktop_dbus::Properties>::get(
            &self,
            "net.connman.iwd.Device",
            "Mode",
        )
    }

    fn set_powered(&self, value: bool) -> nonblock::MethodReply<()> {
        <Self as nonblock::stdintf::org_freedesktop_dbus::Properties>::set(
            &self,
            "net.connman.iwd.Device",
            "Powered",
            value,
        )
    }

    fn set_mode(&self, value: String) -> nonblock::MethodReply<()> {
        <Self as nonblock::stdintf::org_freedesktop_dbus::Properties>::set(
            &self,
            "net.connman.iwd.Device",
            "Mode",
            value,
        )
    }
}

pub trait Station {
    fn connect_hidden_network(&self, name: &str) -> nonblock::MethodReply<()>;
    fn disconnect(&self) -> nonblock::MethodReply<()>;
    fn get_ordered_networks(&self) -> nonblock::MethodReply<Vec<(dbus::Path<'static>, i16)>>;
    fn get_hidden_access_points(&self) -> nonblock::MethodReply<Vec<(String, i16, String)>>;
    fn scan(&self) -> nonblock::MethodReply<()>;
    fn register_signal_level_agent(
        &self,
        path: dbus::Path,
        levels: Vec<i16>,
    ) -> nonblock::MethodReply<()>;
    fn unregister_signal_level_agent(&self, path: dbus::Path) -> nonblock::MethodReply<()>;
    fn connected_network(&self) -> nonblock::MethodReply<dbus::Path<'static>>;
    fn scanning(&self) -> nonblock::MethodReply<bool>;
    fn state(&self) -> nonblock::MethodReply<String>;
}

impl<'a, T: nonblock::NonblockReply, C: ::std::ops::Deref<Target = T>> Station
    for nonblock::Proxy<'a, C>
{
    fn connect_hidden_network(&self, name: &str) -> nonblock::MethodReply<()> {
        self.method_call("net.connman.iwd.Station", "ConnectHiddenNetwork", (name,))
    }

    fn disconnect(&self) -> nonblock::MethodReply<()> {
        self.method_call("net.connman.iwd.Station", "Disconnect", ())
    }

    fn get_ordered_networks(&self) -> nonblock::MethodReply<Vec<(dbus::Path<'static>, i16)>> {
        self.method_call("net.connman.iwd.Station", "GetOrderedNetworks", ())
            .and_then(|r: (Vec<(dbus::Path<'static>, i16)>,)| Ok(r.0))
    }

    fn get_hidden_access_points(&self) -> nonblock::MethodReply<Vec<(String, i16, String)>> {
        self.method_call("net.connman.iwd.Station", "GetHiddenAccessPoints", ())
            .and_then(|r: (Vec<(String, i16, String)>,)| Ok(r.0))
    }

    fn scan(&self) -> nonblock::MethodReply<()> {
        self.method_call("net.connman.iwd.Station", "Scan", ())
    }

    fn register_signal_level_agent(
        &self,
        path: dbus::Path,
        levels: Vec<i16>,
    ) -> nonblock::MethodReply<()> {
        self.method_call(
            "net.connman.iwd.Station",
            "RegisterSignalLevelAgent",
            (path, levels),
        )
    }

    fn unregister_signal_level_agent(&self, path: dbus::Path) -> nonblock::MethodReply<()> {
        self.method_call(
            "net.connman.iwd.Station",
            "UnregisterSignalLevelAgent",
            (path,),
        )
    }

    fn connected_network(&self) -> nonblock::MethodReply<dbus::Path<'static>> {
        <Self as nonblock::stdintf::org_freedesktop_dbus::Properties>::get(
            &self,
            "net.connman.iwd.Station",
            "ConnectedNetwork",
        )
    }

    fn scanning(&self) -> nonblock::MethodReply<bool> {
        <Self as nonblock::stdintf::org_freedesktop_dbus::Properties>::get(
            &self,
            "net.connman.iwd.Station",
            "Scanning",
        )
    }

    fn state(&self) -> nonblock::MethodReply<String> {
        <Self as nonblock::stdintf::org_freedesktop_dbus::Properties>::get(
            &self,
            "net.connman.iwd.Station",
            "State",
        )
    }
}

pub trait SimpleConfiguration {
    fn push_button(&self) -> nonblock::MethodReply<()>;
    fn generate_pin(&self) -> nonblock::MethodReply<String>;
    fn start_pin(&self, pin: &str) -> nonblock::MethodReply<()>;
    fn cancel(&self) -> nonblock::MethodReply<()>;
}

impl<'a, T: nonblock::NonblockReply, C: ::std::ops::Deref<Target = T>> SimpleConfiguration
    for nonblock::Proxy<'a, C>
{
    fn push_button(&self) -> nonblock::MethodReply<()> {
        self.method_call("net.connman.iwd.SimpleConfiguration", "PushButton", ())
    }

    fn generate_pin(&self) -> nonblock::MethodReply<String> {
        self.method_call("net.connman.iwd.SimpleConfiguration", "GeneratePin", ())
            .and_then(|r: (String,)| Ok(r.0))
    }

    fn start_pin(&self, pin: &str) -> nonblock::MethodReply<()> {
        self.method_call("net.connman.iwd.SimpleConfiguration", "StartPin", (pin,))
    }

    fn cancel(&self) -> nonblock::MethodReply<()> {
        self.method_call("net.connman.iwd.SimpleConfiguration", "Cancel", ())
    }
}

pub trait Network {
    fn connect(&self) -> nonblock::MethodReply<()>;
    fn name(&self) -> nonblock::MethodReply<String>;
    fn connected(&self) -> nonblock::MethodReply<bool>;
    fn device(&self) -> nonblock::MethodReply<dbus::Path<'static>>;
    fn type_(&self) -> nonblock::MethodReply<String>;
    fn known_network(&self) -> nonblock::MethodReply<dbus::Path<'static>>;
}

impl<'a, T: nonblock::NonblockReply, C: ::std::ops::Deref<Target = T>> Network
    for nonblock::Proxy<'a, C>
{
    fn connect(&self) -> nonblock::MethodReply<()> {
        self.method_call("net.connman.iwd.Network", "Connect", ())
    }

    fn name(&self) -> nonblock::MethodReply<String> {
        <Self as nonblock::stdintf::org_freedesktop_dbus::Properties>::get(
            &self,
            "net.connman.iwd.Network",
            "Name",
        )
    }

    fn connected(&self) -> nonblock::MethodReply<bool> {
        <Self as nonblock::stdintf::org_freedesktop_dbus::Properties>::get(
            &self,
            "net.connman.iwd.Network",
            "Connected",
        )
    }

    fn device(&self) -> nonblock::MethodReply<dbus::Path<'static>> {
        <Self as nonblock::stdintf::org_freedesktop_dbus::Properties>::get(
            &self,
            "net.connman.iwd.Network",
            "Device",
        )
    }

    fn type_(&self) -> nonblock::MethodReply<String> {
        <Self as nonblock::stdintf::org_freedesktop_dbus::Properties>::get(
            &self,
            "net.connman.iwd.Network",
            "Type",
        )
    }

    fn known_network(&self) -> nonblock::MethodReply<dbus::Path<'static>> {
        <Self as nonblock::stdintf::org_freedesktop_dbus::Properties>::get(
            &self,
            "net.connman.iwd.Network",
            "KnownNetwork",
        )
    }
}
