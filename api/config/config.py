import toml
import logging
import ipaddress
from functools import cached_property
from .mixin import ConfigMixin


log = logging.getLogger('quart.app')
CONFIG_NOTICE = """\
# === WARNING ===
# This configuration is automatically generated by vagabond
# Manual edits will be overwritten
# To update values here, update the vagabond configuration and reload\
"""


def deep_merge(left, right, path=[]):
    for key in right:
        if key in left:
            if isinstance(left[key], dict) and isinstance(right[key], dict):
                deep_merge(left[key], right[key], path + [str(key)])
            elif type(left[key]) != type(right[key]):
                raise Exception(
                    f"Unexpected key type for '{'.'.join(path)}.{key}'! Expected {type(left[key]).__name__}")
            else:
                left[key] = right[key]
        else:
            raise Exception(f"Unknown key path '{'.'.join(path)}.{key}'!")

    return left


CONFIG_DEFAULTS = {
    'network': {
        'domain': 'vagabond.lan',
        'subnet': '192.168.1.0/24',
        'address': '192.168.1.1',
        'connection': [],
        'lan': {
            'enabled': True,
            'interface': 'eth0',
        },
        'wlan': {
            'enabled': True,
            'interface': 'wlan0',
            'ssid': 'vagabond',
            'hostapd_config': '',
        },
    },
    'dns': {
        'enabled': True,
        'block_malicious': True,
        'servers': ['1.1.1.1', '1.0.0.1'],
        'extra_config': "",
    },
    'dhcp': {
        'enabled': True,
        'range': {
            'start': '192.168.1.100',
            'end': '192.168.1.199',
        },
        'extra_config': "",
    }
}


class Config(ConfigMixin):
    def __init__(self, cfg_path: str):
        self._config = deep_merge(CONFIG_DEFAULTS, toml.load(cfg_path))

    def asdict(self):
        return {
            'config_notice': CONFIG_NOTICE,
            'dns': self.dns.asdict(),
            'network': self.network.asdict(),
            'dhcp': self.dhcp.asdict(),
        }

    @cached_property
    def dns(self):
        return Dns(self._config)

    @cached_property
    def network(self):
        return Network(self._config)

    @cached_property
    def dhcp(self):
        return Dhcp(self._config)


class Network(ConfigMixin):
    def __init__(self, cfg: dict):
        self._config = cfg

    def asdict(self):
        return {
            'domain': self.domain,
            'address': self.address,
            'wlan_enabled': self.wlan_enabled,
            'wlan_interface': self.wlan_interface,
            'wlan_ssid': self.wlan_ssid,
            'wlan_hostapd_config': self.wlan_hostapd_config,
            'lan_enabled': self.lan_enabled,
            'lan_interface': self.lan_interface,
            'subnet': f"{self.subnet}",
            'subnet_address': self.subnet_address,
            'subnet_mask': self.subnet_mask,
            'subnet_broadcast': self.subnet_broadcast,
        }

    @cached_property
    def domain(self):
        return self.get_path("network.domain")

    @cached_property
    def address(self):
        return self.get_path("network.address")

    @cached_property
    def wlan_enabled(self):
        return self.get_path("network.wlan.enabled")

    @cached_property
    def wlan_interface(self):
        return self.get_path("network.wlan.interface")

    @cached_property
    def wlan_ssid(self):
        return self.get_path("network.wlan.ssid")

    @cached_property
    def wlan_hostapd_config(self):
        return self.get_path("network.wlan.hostapd_config")

    @cached_property
    def lan_enabled(self):
        return self.get_path("network.lan.enabled")

    @cached_property
    def lan_interface(self):
        return self.get_path("network.lan.interface")

    @cached_property
    def subnet(self):
        return ipaddress.ip_network(self.get_path("network.subnet"), strict=False)

    @property
    def subnet_address(self):
        return self.subnet.network_address

    @property
    def subnet_mask(self):
        return self.subnet.netmask

    @property
    def subnet_broadcast(self):
        return self.subnet.broadcast_address


class Dhcp(ConfigMixin):
    def __init__(self, cfg: dict):
        self._config = cfg

    def asdict(self):
        return {
            'enabled': self.enabled,
            'range_start': self.range_start,
            'range_end': self.range_end,
            'extra_config': self.extra_config,
        }

    @cached_property
    def enabled(self):
        return self.get_path("dhcp.enabled")

    @cached_property
    def range_start(self):
        return self.get_path("dhcp.range.start")

    @cached_property
    def range_end(self):
        return self.get_path("dhcp.range.end")

    @cached_property
    def extra_config(self):
        return self.get_path("dhcp.extra_config")


class Dns(ConfigMixin):
    def __init__(self, cfg: dict):
        self._config = cfg

    def asdict(self):
        return {
            'enabled': self.enabled,
            'block_malicious': self.block_malicious,
            'servers': self.servers,
            'extra_config': self.extra_config,
        }

    @cached_property
    def enabled(self):
        return self.get_path("dns.enabled")

    @cached_property
    def block_malicious(self):
        return self.get_path("dns.block_malicious")

    @cached_property
    def servers(self):
        return self.get_path("dns.servers")

    @cached_property
    def extra_config(self):
        return self.get_path("dns.extra_config")
